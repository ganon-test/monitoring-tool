/**
 * Proxmoxç›£è¦–ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ - ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
 * Node.jsãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã¨é€£æºã—ã¦ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤º
 */

class ProxmoxDashboard {
    constructor() {
        this.socket = null;
        this.charts = {};
        this.lastData = null;
        this.updateInterval = null;
        
        this.init();
    }

    async init() {
        console.log('ğŸš€ ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰åˆæœŸåŒ–é–‹å§‹');
        
        // Socket.IOæ¥ç¶š
        this.connectSocket();
        
        // ãƒãƒ£ãƒ¼ãƒˆåˆæœŸåŒ–
        this.initCharts();
        
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
        this.setupEventListeners();
        
        // åˆæœŸãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
        await this.loadInitialData();
        
        // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’éš ã™
        this.hideLoading();
        
        console.log('âœ… ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰åˆæœŸåŒ–å®Œäº†');
    }

    connectSocket() {
        console.log('ğŸ”Œ WebSocketæ¥ç¶šä¸­...');
        
        this.socket = io();
        
        this.socket.on('connect', () => {
            console.log('âœ… WebSocketæ¥ç¶šæˆåŠŸ');
            this.updateConnectionStatus(true);
        });
        
        this.socket.on('disconnect', () => {
            console.log('âŒ WebSocketåˆ‡æ–­');
            this.updateConnectionStatus(false);
        });
        
        this.socket.on('data_update', (data) => {
            console.log('ğŸ“Š ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿å—ä¿¡:', data);
            console.log('ğŸ“ˆ ãƒ‡ãƒ¼ã‚¿è©³ç´°:', {
                nodes: data?.nodes?.length || 0,
                vms: data?.vms?.length || 0,
                storage: data?.storage?.length || 0,
                status: data?.cluster_status || 'unknown'
            });
            
            // ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ãƒ›ã‚¹ãƒˆæƒ…å ±ã‚’æ›´æ–°
            this.updateClusterInfo(data);
            
            this.updateDashboard(data);
        });
        
        this.socket.on('connect_error', (error) => {
            console.error('âŒ WebSocketæ¥ç¶šã‚¨ãƒ©ãƒ¼:', error);
            this.updateConnectionStatus(false);
        });
    }

    updateConnectionStatus(connected) {
        const statusElement = document.getElementById('connectionStatus');
        const dot = statusElement.querySelector('.status-dot');
        const span = statusElement.querySelector('span');
        
        if (connected) {
            dot.classList.remove('disconnected');
            span.textContent = 'æ¥ç¶šæ¸ˆã¿';
        } else {
            dot.classList.add('disconnected');
            span.textContent = 'åˆ‡æ–­ä¸­';
        }
    }

    initCharts() {
        // CPUãƒãƒ£ãƒ¼ãƒˆ
        const cpuCtx = document.getElementById('cpuChart').getContext('2d');
        this.charts.cpu = new Chart(cpuCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'CPUä½¿ç”¨ç‡ (%)',
                    data: [],
                    borderColor: '#3b82f6',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        labels: { color: '#cbd5e1' }
                    }
                },
                scales: {
                    x: {
                        ticks: { color: '#64748b' },
                        grid: { color: '#334155' }
                    },
                    y: {
                        min: 0,
                        max: 100,
                        ticks: { color: '#64748b' },
                        grid: { color: '#334155' }
                    }
                },
                elements: {
                    point: {
                        radius: 0,
                        hoverRadius: 6
                    }
                }
            }
        });

        // ãƒ¡ãƒ¢ãƒªãƒãƒ£ãƒ¼ãƒˆ
        const memoryCtx = document.getElementById('memoryChart').getContext('2d');
        this.charts.memory = new Chart(memoryCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡ (%)',
                    data: [],
                    borderColor: '#10b981',
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        labels: { color: '#cbd5e1' }
                    }
                },
                scales: {
                    x: {
                        ticks: { color: '#64748b' },
                        grid: { color: '#334155' }
                    },
                    y: {
                        min: 0,
                        max: 100,
                        ticks: { color: '#64748b' },
                        grid: { color: '#334155' }
                    }
                },
                elements: {
                    point: {
                        radius: 0,
                        hoverRadius: 6
                    }
                }
            }
        });
    }

    setupEventListeners() {
        // æ›´æ–°ãƒœã‚¿ãƒ³
        document.getElementById('refreshNodes')?.addEventListener('click', () => {
            this.loadInitialData();
        });

        // VMãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                this.filterVMs(e.target.dataset.filter);
            });
        });

        // æ™‚é–“ç¯„å›²é¸æŠ
        document.getElementById('cpuTimeRange')?.addEventListener('change', (e) => {
            this.updateChartTimeRange('cpu', e.target.value);
        });

        document.getElementById('memoryTimeRange')?.addEventListener('change', (e) => {
            this.updateChartTimeRange('memory', e.target.value);
        });

        // ãƒ“ãƒ¥ãƒ¼åˆ‡ã‚Šæ›¿ãˆ
        document.querySelectorAll('.toggle-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                this.toggleNodesView(e.target.dataset.view);
            });
        });

        // ã‚¨ãƒ©ãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ«
        document.getElementById('errorModalClose')?.addEventListener('click', () => {
            this.hideErrorModal();
        });

        document.getElementById('errorModalOk')?.addEventListener('click', () => {
            this.hideErrorModal();
        });
    }

    async loadInitialData() {
        try {
            console.log('ğŸ“¡ åˆæœŸãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ä¸­...');
            this.showLoading();

            // ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å–å¾—
            const statusResponse = await fetch('/api/status');
            const statusData = await statusResponse.json();

            if (statusData.success) {
                this.updateDashboard(statusData.data);
            }

            // å±¥æ­´ãƒ‡ãƒ¼ã‚¿å–å¾—
            const historyResponse = await fetch('/api/history');
            const historyData = await historyResponse.json();

            if (historyData.success) {
                this.updateCharts(historyData.data);
            }

        } catch (error) {
            console.error('âŒ åˆæœŸãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
            this.showError('ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
        } finally {
            this.hideLoading();
        }
    }

    updateDashboard(data) {
        console.log('ğŸ”„ ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰æ›´æ–°é–‹å§‹:', data);
        
        if (!data) {
            console.warn('âš ï¸ ãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™');
            return;
        }
        
        this.lastData = data;
        
        // æœ€çµ‚æ›´æ–°æ™‚åˆ»
        document.getElementById('lastUpdate').textContent = 
            `æœ€çµ‚æ›´æ–°: ${new Date().toLocaleTimeString()}`;

        // æ¦‚è¦ã‚«ãƒ¼ãƒ‰æ›´æ–°
        this.updateOverviewCards(data);
        
        // ãƒãƒ¼ãƒ‰æƒ…å ±æ›´æ–°
        this.updateNodes(data.nodes || []);
        
        // VM/CTæƒ…å ±æ›´æ–°
        this.updateVMs([...(data.vms || []), ...(data.containers || [])]);
        
        console.log('âœ… ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰æ›´æ–°å®Œäº†');
    }

    updateOverviewCards(data) {
        const nodes = data.nodes || [];
        const vms = data.vms || [];
        const containers = data.containers || [];
        const storage = data.storage || [];
        
        console.log('ğŸ“Š æ¦‚è¦ã‚«ãƒ¼ãƒ‰æ›´æ–°é–‹å§‹:', { 
            nodes: nodes.length, 
            vms: vms.length, 
            containers: containers.length,
            storage: storage.length 
        });
        
        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒãƒ¼ãƒ‰ã®ã¿ã‚’å¯¾è±¡
        const activeNodes = nodes.filter(node => node.status === 'online');
        
        // åŸºæœ¬çµ±è¨ˆ
        const totalVMs = vms.length;
        const totalContainers = containers.length;
        const runningVMs = vms.filter(vm => vm.status === 'running');
        const runningContainers = containers.filter(ct => ct.status === 'running');
        const runningVMsCount = runningVMs.length;
        const runningContainersCount = runningContainers.length;
        
        // CPUçµ±è¨ˆï¼ˆã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒãƒ¼ãƒ‰ã®åˆè¨ˆã¨å¹³å‡ï¼‰
        let totalCpuUsed = 0;
        let totalCpuCores = 0;
        let cpuCount = 0;
        activeNodes.forEach(node => {
            if (node.cpu !== undefined && node.maxcpu !== undefined) {
                totalCpuUsed += (node.cpu / 100) * node.maxcpu;
                totalCpuCores += node.maxcpu;
                cpuCount++;
            }
        });
        const avgCpu = cpuCount > 0 ? (totalCpuUsed / totalCpuCores * 100) : 0;

        // ãƒ¡ãƒ¢ãƒªçµ±è¨ˆï¼ˆã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒãƒ¼ãƒ‰ã®åˆè¨ˆï¼‰
        let totalMemoryUsed = 0;
        let totalMemoryMax = 0;
        activeNodes.forEach(node => {
            if (node.memory_used !== undefined && node.memory_total !== undefined) {
                totalMemoryUsed += node.memory_used;
                totalMemoryMax += node.memory_total;
            }
        });
        const memoryUsage = totalMemoryMax > 0 ? (totalMemoryUsed / totalMemoryMax * 100) : 0;

        // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸çµ±è¨ˆ
        let totalStorageUsed = 0;
        let totalStorageMax = 0;
        storage.forEach(store => {
            if (store.used !== undefined && store.total !== undefined) {
                totalStorageUsed += store.used;
                totalStorageMax += store.total;
            }
        });
        const storageUsage = totalStorageMax > 0 ? (totalStorageUsed / totalStorageMax * 100) : 0;

        // è² è·å¹³å‡çµ±è¨ˆ
        let totalLoad1 = 0;
        let totalLoad5 = 0;
        let totalLoad15 = 0;
        let loadCount = 0;
        activeNodes.forEach(node => {
            if (node.loadavg && Array.isArray(node.loadavg)) {
                totalLoad1 += node.loadavg[0] || 0;
                totalLoad5 += node.loadavg[1] || 0;
                totalLoad15 += node.loadavg[2] || 0;
                loadCount++;
            }
        });
        const avgLoad1 = loadCount > 0 ? (totalLoad1 / loadCount) : 0;
        const avgLoad5 = loadCount > 0 ? (totalLoad5 / loadCount) : 0;
        const avgLoad15 = loadCount > 0 ? (totalLoad15 / loadCount) : 0;

        // DOMè¦ç´ ã®æ›´æ–°
        this.safeUpdateElement('activeNodes', activeNodes.length);
        this.safeUpdateElement('totalNodes', nodes.length);
        this.safeUpdateElement('runningVms', runningVMsCount + runningContainersCount);
        this.safeUpdateElement('totalVms', totalVMs + totalContainers);
        this.safeUpdateElement('runningVmsCount', runningVMsCount);
        this.safeUpdateElement('runningCtCount', runningContainersCount);
        
        // CPUçµ±è¨ˆ
        this.safeUpdateElement('overallCpuUsage', `${avgCpu.toFixed(1)}%`);
        this.safeUpdateElement('cpuCoresUsed', Math.round(totalCpuUsed));
        this.safeUpdateElement('cpuCoresTotal', totalCpuCores);
        this.updateProgressBar('cpuProgressBar', avgCpu);
        
        // ãƒ¡ãƒ¢ãƒªçµ±è¨ˆ
        this.safeUpdateElement('overallMemoryUsage', `${memoryUsage.toFixed(1)}%`);
        this.safeUpdateElement('memoryUsed', this.formatBytes(totalMemoryUsed, 1));
        this.safeUpdateElement('memoryTotal', this.formatBytes(totalMemoryMax, 1));
        this.updateProgressBar('memoryProgressBar', memoryUsage);
        
        // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸çµ±è¨ˆ
        this.safeUpdateElement('overallStorageUsage', `${storageUsage.toFixed(1)}%`);
        this.safeUpdateElement('storageUsed', this.formatBytes(totalStorageUsed, 1));
        this.safeUpdateElement('storageTotal', this.formatBytes(totalStorageMax, 1));
        this.updateProgressBar('storageProgressBar', storageUsage);
        
        // è² è·å¹³å‡
        this.safeUpdateElement('overallLoadAverage', avgLoad1.toFixed(2));
        this.safeUpdateElement('loadAverage1m', avgLoad1.toFixed(2));
        this.safeUpdateElement('loadAverage5m', avgLoad5.toFixed(2));
        this.safeUpdateElement('loadAverage15m', avgLoad15.toFixed(2));

        // ãƒˆãƒ¬ãƒ³ãƒ‰ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼æ›´æ–°
        this.updateTrendIndicator('nodeTrend', activeNodes.length === nodes.length);
        
        console.log('âœ… æ¦‚è¦ã‚«ãƒ¼ãƒ‰æ›´æ–°å®Œäº†:', {
            avgCpu: avgCpu.toFixed(1),
            memoryUsage: memoryUsage.toFixed(1),
            storageUsage: storageUsage.toFixed(1),
            activeNodes: activeNodes.length,
            totalVMs: totalVMs + totalContainers
        });
    }

    // ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼šå®‰å…¨ãªDOMè¦ç´ æ›´æ–°
    safeUpdateElement(id, value) {
        const element = document.getElementById(id);
        if (element) {
            element.textContent = value;
        }
    }

    // ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼šãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼æ›´æ–°
    updateProgressBar(id, percentage) {
        const element = document.getElementById(id);
        if (element) {
            element.style.width = `${Math.min(100, Math.max(0, percentage))}%`;
        }
    }

    // ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼šãƒˆãƒ¬ãƒ³ãƒ‰ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼æ›´æ–°
    updateTrendIndicator(id, isGood) {
        const element = document.getElementById(id);
        if (element) {
            const icon = element.querySelector('i');
            if (icon) {
                icon.className = isGood ? 'fas fa-check-circle' : 'fas fa-exclamation-triangle';
            }
            element.style.color = isGood ? 'var(--success-color)' : 'var(--warning-color)';
        }
    }

    // ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼šãƒã‚¤ãƒˆå˜ä½ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
    formatBytes(bytes, decimals = 2) {
        if (bytes === 0) return '0 GB';
        
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    // ãƒ“ãƒ¥ãƒ¼åˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½
    toggleNodesView(view) {
        const container = document.getElementById('nodesContainer');
        if (container) {
            container.className = `nodes-container ${view}-view`;
        }
    }

    updateTrend(elementId, change) {
        const element = document.getElementById(elementId);
        if (!element) return;
        
        element.className = 'card-trend';
        
        if (change > 0) {
            element.classList.add('up');
            icon.className = 'fas fa-arrow-up';
        } else if (change < 0) {
            element.classList.add('down');
            icon.className = 'fas fa-arrow-down';
        } else {
            element.classList.add('neutral');
            icon.className = 'fas fa-minus';
        }
        
        span.textContent = `${Math.abs(change).toFixed(1)}%`;
    }

    updateNodes(nodes) {
        const container = document.getElementById('nodesContainer');
        container.innerHTML = '';

        nodes.forEach(node => {
            const nodeCard = this.createNodeCard(node);
            container.appendChild(nodeCard);
        });
    }

    createNodeCard(node) {
        const card = document.createElement('div');
        card.className = 'node-card enhanced';
        
        try {
            const statusClass = node.status === 'online' ? 'online' : 'offline';
            const cpuUsage = node.cpu || 0;
            
            // ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡ã®æ­£ç¢ºãªè¨ˆç®—
            let memoryUsage = 0;
            let memoryText = '0 GB / 0 GB';
            
            if (node.memory_percent !== undefined) {
                memoryUsage = node.memory_percent;
            } else if (node.memory_total && node.memory_total > 0) {
                memoryUsage = (node.memory_used / node.memory_total) * 100;
            }
            
            if (node.memory_used && node.memory_total) {
                const usedGB = (node.memory_used / 1024 / 1024 / 1024).toFixed(1);
                const totalGB = (node.memory_total / 1024 / 1024 / 1024).toFixed(1);
                memoryText = `${usedGB} GB / ${totalGB} GB`;
            }
            
            // ã‚¢ãƒƒãƒ—ã‚¿ã‚¤ãƒ è¨ˆç®—
            const uptimeText = this.formatUptime(node.uptime || 0);
            
            // ãƒ­ãƒ¼ãƒ‰ã‚¢ãƒ™ãƒ¬ãƒ¼ã‚¸ï¼ˆå®‰å…¨ãªå‡¦ç†ï¼‰
            let loadText = '0.00 / 0.00 / 0.00';
            if (node.loadavg) {
                if (Array.isArray(node.loadavg)) {
                    const [load1, load5, load15] = node.loadavg;
                    loadText = `${(load1 || 0).toFixed(2)} / ${(load5 || 0).toFixed(2)} / ${(load15 || 0).toFixed(2)}`;
                } else {
                    console.warn(`âš ï¸ ãƒ­ãƒ¼ãƒ‰ã‚¢ãƒ™ãƒ¬ãƒ¼ã‚¸ãŒé…åˆ—ã§ã¯ã‚ã‚Šã¾ã›ã‚“: ${node.name}`, node.loadavg);
                }
            }
            
            console.log(`ğŸ–¥ï¸ ãƒãƒ¼ãƒ‰ ${node.name}: CPU=${cpuUsage.toFixed(1)}%, ãƒ¡ãƒ¢ãƒª=${memoryUsage.toFixed(1)}%`);
        
            card.innerHTML = `
                <div class="node-header">
                    <div class="node-info">
                        <div class="node-title">${node.name || node.node}</div>
                        <div class="node-subtitle">
                            ${node.source_host ? `ãƒ‡ãƒ¼ã‚¿å…ƒ: ${node.source_host}` : ''}
                            ${uptimeText ? ` â€¢ ã‚¢ãƒƒãƒ—ã‚¿ã‚¤ãƒ : ${uptimeText}` : ''}
                        </div>
                    </div>
                    <div class="status-badge ${statusClass}">${node.status}</div>
                </div>
                
                <div class="resource-grid">
                    <div class="resource-card cpu">
                        <div class="resource-header">
                            <div class="resource-icon">
                                <i class="fas fa-microchip"></i>
                            </div>
                            <div class="resource-title">CPUä½¿ç”¨ç‡</div>
                        </div>
                        <div class="resource-value">${cpuUsage.toFixed(1)}%</div>
                        <div class="progress-bar">
                            <div class="progress-fill ${this.getProgressClass(cpuUsage)}" 
                                 style="width: ${Math.min(cpuUsage, 100)}%"></div>
                        </div>
                    </div>
                    
                    <div class="resource-card memory">
                        <div class="resource-header">
                            <div class="resource-icon">
                                <i class="fas fa-memory"></i>
                            </div>
                            <div class="resource-title">ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡</div>
                        </div>
                        <div class="resource-value">${memoryUsage.toFixed(1)}%</div>
                        <div class="resource-detail">${memoryText}</div>
                        <div class="progress-bar">
                            <div class="progress-fill ${this.getProgressClass(memoryUsage)}" 
                                 style="width: ${Math.min(memoryUsage, 100)}%"></div>
                        </div>
                    </div>
                    
                    <div class="resource-card load">
                        <div class="resource-header">
                            <div class="resource-icon">
                                <i class="fas fa-chart-line"></i>
                            </div>
                            <div class="resource-title">ãƒ­ãƒ¼ãƒ‰ã‚¢ãƒ™ãƒ¬ãƒ¼ã‚¸</div>
                        </div>
                        <div class="resource-value load-values">${loadText}</div>
                        <div class="resource-detail">1åˆ† / 5åˆ† / 15åˆ†</div>
                    </div>
                </div>
            `;
            
        } catch (error) {
            console.error(`âŒ ãƒãƒ¼ãƒ‰ã‚«ãƒ¼ãƒ‰ä½œæˆã‚¨ãƒ©ãƒ¼ (${node.name}):`, error);
            card.innerHTML = `
                <div class="node-header">
                    <div class="node-info">
                        <div class="node-title">${node.name || node.node}</div>
                        <div class="node-subtitle">ã‚¨ãƒ©ãƒ¼: ã‚«ãƒ¼ãƒ‰ä½œæˆã«å¤±æ•—</div>
                    </div>
                    <div class="status-badge offline">error</div>
                </div>
            `;
        }
        
        return card;
        return card;
    }

    formatUptime(seconds) {
        if (!seconds || seconds === 0) return '0åˆ†';
        
        const days = Math.floor(seconds / 86400);
        const hours = Math.floor((seconds % 86400) / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        
        if (days > 0) {
            return `${days}æ—¥${hours}æ™‚é–“`;
        } else if (hours > 0) {
            return `${hours}æ™‚é–“${minutes}åˆ†`;
        } else {
            return `${minutes}åˆ†`;
        }
    }

    updateVMs(vms) {
        const container = document.getElementById('vmsContainer');
        container.innerHTML = '';

        vms.forEach(vm => {
            const vmCard = this.createVMCard(vm);
            container.appendChild(vmCard);
        });
    }

    createVMCard(vm) {
        const card = document.createElement('div');
        card.className = 'vm-card';
        card.dataset.status = vm.status;
        
        const statusClass = vm.status === 'running' ? 'running' : 'stopped';
        const cpuUsage = vm.cpu || 0;
        const memoryUsage = vm.memory ? (vm.memory.used / vm.memory.total * 100) : 0;
        const type = vm.type === 'qemu' ? 'VM' : 'CT';
        
        card.innerHTML = `
            <div class="vm-header">
                <div class="vm-title">${vm.name} (${type}${vm.vmid})</div>
                <div class="status-badge ${statusClass}">${vm.status}</div>
            </div>
            <div class="resource-info">
                <div class="resource-item">
                    <div class="resource-label">CPUä½¿ç”¨ç‡</div>
                    <div class="resource-value">${cpuUsage.toFixed(1)}%</div>
                    <div class="progress-bar">
                        <div class="progress-fill ${this.getProgressClass(cpuUsage)}" 
                             style="width: ${cpuUsage}%"></div>
                    </div>
                </div>
                <div class="resource-item">
                    <div class="resource-label">ãƒ¡ãƒ¢ãƒªä½¿ç”¨ç‡</div>
                    <div class="resource-value">${memoryUsage.toFixed(1)}%</div>
                    <div class="progress-bar">
                        <div class="progress-fill ${this.getProgressClass(memoryUsage)}" 
                             style="width: ${memoryUsage}%"></div>
                    </div>
                </div>
            </div>
        `;
        
        return card;
    }

    getProgressClass(percentage) {
        if (percentage >= 80) return 'danger';
        if (percentage >= 60) return 'warning';
        return '';
    }

    filterVMs(filter) {
        const vmCards = document.querySelectorAll('.vm-card');
        
        vmCards.forEach(card => {
            const status = card.dataset.status;
            let show = false;
            
            switch (filter) {
                case 'all':
                    show = true;
                    break;
                case 'running':
                    show = status === 'running';
                    break;
                case 'stopped':
                    show = status === 'stopped';
                    break;
            }
            
            card.style.display = show ? 'block' : 'none';
        });
    }

    updateCharts(historyData) {
        if (!historyData || historyData.length === 0) return;

        // æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ã‚’æº–å‚™
        const labels = historyData.map(item => 
            new Date(item.timestamp).toLocaleTimeString('ja-JP', { 
                hour: '2-digit', 
                minute: '2-digit' 
            })
        );

        const cpuData = historyData.map(item => item.avg_cpu || 0);
        const memoryData = historyData.map(item => item.avg_memory || 0);

        // CPUãƒãƒ£ãƒ¼ãƒˆæ›´æ–°
        this.charts.cpu.data.labels = labels;
        this.charts.cpu.data.datasets[0].data = cpuData;
        this.charts.cpu.update('none');

        // ãƒ¡ãƒ¢ãƒªãƒãƒ£ãƒ¼ãƒˆæ›´æ–°
        this.charts.memory.data.labels = labels;
        this.charts.memory.data.datasets[0].data = memoryData;
        this.charts.memory.update('none');
    }

    updateChartTimeRange(chartType, timeRange) {
        // æ™‚é–“ç¯„å›²ã«åŸºã¥ã„ã¦ãƒ‡ãƒ¼ã‚¿ã‚’å†å–å¾—
        // ç°¡ç•¥åŒ–ã®ãŸã‚ã€ç¾åœ¨ã¯å…¨ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤º
        console.log(`ğŸ“ˆ ${chartType}ãƒãƒ£ãƒ¼ãƒˆã®æ™‚é–“ç¯„å›²ã‚’${timeRange}ã«å¤‰æ›´`);
    }

    showLoading() {
        document.getElementById('loadingOverlay').style.display = 'flex';
    }

    hideLoading() {
        document.getElementById('loadingOverlay').style.display = 'none';
    }

    showError(message) {
        document.getElementById('errorMessage').textContent = message;
        document.getElementById('errorModal').classList.add('show');
    }

    hideErrorModal() {
        document.getElementById('errorModal').classList.remove('show');
    }

    updateClusterInfo(data) {
        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–APIãƒ›ã‚¹ãƒˆæƒ…å ±ã‚’æ›´æ–°
        const clusterHostsElement = document.getElementById('clusterHosts');
        
        if (clusterHostsElement) {
            if (data?.active_api_host) {
                clusterHostsElement.textContent = data.active_api_host;
                clusterHostsElement.style.color = 'var(--success-color)';
            } else if (data?.cluster_status === 'offline') {
                clusterHostsElement.textContent = 'ã‚ªãƒ•ãƒ©ã‚¤ãƒ³';
                clusterHostsElement.style.color = 'var(--danger-color)';
            } else {
                clusterHostsElement.textContent = '--';
                clusterHostsElement.style.color = 'var(--text-muted)';
            }
        }
        
        console.log('ğŸ  ã‚¢ã‚¯ãƒ†ã‚£ãƒ–APIãƒ›ã‚¹ãƒˆ:', data?.active_api_host || 'ãªã—');
    }
}

// ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰åˆæœŸåŒ–
document.addEventListener('DOMContentLoaded', () => {
    new ProxmoxDashboard();
});

// ãƒ‡ãƒãƒƒã‚°ç”¨ï¼ˆé–‹ç™ºæ™‚ã®ã¿ï¼‰
if (typeof window !== 'undefined') {
    window.dashboard = ProxmoxDashboard;
}
