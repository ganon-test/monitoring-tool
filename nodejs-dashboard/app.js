/**
 * ProxmoxÁõ£Ë¶ñ„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ - Node.jsÁâà
 * Proxmox API„Åã„ÇâÁõ¥Êé•„Éá„Éº„Çø„ÇíÂèñÂæó„Åó„Å¶„É™„Ç¢„É´„Çø„Ç§„É†Ë°®Á§∫
 */

const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const axios = require('axios');
const https = require('https');
const fs = require('fs');
const path = require('path');
const yaml = require('yaml');
const sqlite3 = require('sqlite3').verbose();
const cors = require('cors');

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
    cors: {
        origin: "*",
        methods: ["GET", "POST"]
    }
});

// Ë®≠ÂÆö
const PORT = process.env.PORT || 3000;
const CONFIG_PATH = process.env.CONFIG_PATH || '../config.yaml';

// „Éü„Éâ„É´„Ç¶„Çß„Ç¢
app.use(cors());
app.use(express.json());
app.use(express.static('public'));

class ProxmoxClient {
    constructor(host, username, password, verifySSL = false) {
        this.host = host;
        this.username = username;
        this.password = password;
        this.verifySSL = verifySSL;
        this.ticket = null;
        this.csrfToken = null;
        
        // SSLË®ºÊòéÊõ∏„ÇíÁÑ°Ë¶ñ„Åô„ÇãHTTPS„Ç®„Éº„Ç∏„Çß„É≥„Éà
        this.httpsAgent = new https.Agent({
            rejectUnauthorized: verifySSL
        });
    }

    async authenticate() {
        try {
            const authUrl = `https://${this.host}:8006/api2/json/access/ticket`;
            const authData = {
                username: this.username,
                password: this.password
            };

            console.log(`üîê Ë™çË®ºË©¶Ë°å: ${this.host} (user: ${this.username})`);

            const response = await axios.post(authUrl, authData, {
                httpsAgent: this.httpsAgent,
                timeout: 5000  // Áü≠„ÅÑ„Çø„Ç§„É†„Ç¢„Ç¶„Éà
            });

            if (response.data && response.data.data) {
                this.ticket = response.data.data.ticket;
                this.csrfToken = response.data.data.CSRFPreventionToken;
                console.log(`‚úÖ ProxmoxË™çË®ºÊàêÂäü: ${this.host}`);
                return true;
            } else {
                console.error(`‚ùå Ë™çË®º„É¨„Çπ„Éù„É≥„Çπ‰∏çÊ≠£ ${this.host}:`, response.data);
                return false;
            }
        } catch (error) {
            console.error(`‚ùå ProxmoxË™çË®ºÂ§±Êïó ${this.host}:`, {
                message: error.message,
                code: error.code,
                status: error.response?.status
            });
            return false;
        }
    }

    async apiRequest(endpoint) {
        if (!this.ticket) {
            const authSuccess = await this.authenticate();
            if (!authSuccess) return null;
        }

        try {
            const url = `https://${this.host}:8006/api2/json${endpoint}`;
            const response = await axios.get(url, {
                headers: {
                    'Cookie': `PVEAuthCookie=${this.ticket}`,
                    'CSRFPreventionToken': this.csrfToken
                },
                httpsAgent: this.httpsAgent,
                timeout: 8000  // APIÂëº„Å≥Âá∫„ÅóÁî®„ÅÆ„Çø„Ç§„É†„Ç¢„Ç¶„Éà
            });

            return response.data?.data || null;
        } catch (error) {
            if (error.response?.status === 401) {
                // Ë™çË®º„ÅåÂàá„Çå„ÅüÂ†¥Âêà„ÅØÂÜçË™çË®º
                this.ticket = null;
                return await this.apiRequest(endpoint);
            }
            
            // „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Ç®„É©„Éº„ÇÑ„Çø„Ç§„É†„Ç¢„Ç¶„Éà„ÅÆÂ†¥Âêà„ÅØË©≥Á¥∞„É≠„Ç∞
            console.error(`API „É™„ÇØ„Ç®„Çπ„Éà„Ç®„É©„Éº ${this.host}${endpoint}:`, {
                message: error.message,
                code: error.code,
                status: error.response?.status
            });
            throw error; // „Ç®„É©„Éº„Çí‰∏ä‰Ωç„Å´‰ºùÊí≠
        }
    }

    async getClusterData() {
        console.log(`üì° Proxmox„Éá„Éº„ÇøÂèñÂæóÈñãÂßã: ${this.host}`);
        
        const data = {
            nodes: [],
            vms: [],
            storage: [],
            cluster_status: 'online'
        };

        try {
            // „Éé„Éº„Éâ‰∏ÄË¶ßÂèñÂæóÔºà„Åæ„ÅöÊé•Á∂öÊÄß„ÇíÁ¢∫Ë™çÔºâ
            const nodes = await this.apiRequest('/nodes');
            if (!nodes || nodes.length === 0) {
                console.warn(`‚ö†Ô∏è „Éé„Éº„ÉâÊÉÖÂ†±„ÅåÁ©∫: ${this.host}`);
                data.cluster_status = 'offline';
                return data;
            }

            console.log(`üìä ${nodes.length}ÂÄã„ÅÆ„Éé„Éº„Éâ„ÇíÁô∫Ë¶ã: ${this.host}`);

            for (const node of nodes) {
                const nodeName = node.node;
                console.log(`üìä „Éé„Éº„ÉâÂá¶ÁêÜ‰∏≠: ${nodeName} @ ${this.host}`);

                try {
                    // „Éé„Éº„ÉâË©≥Á¥∞ÊÉÖÂ†±
                    const status = await this.apiRequest(`/nodes/${nodeName}/status`);
                    if (status) {
                        const memoryUsed = status.memory?.used || 0;
                        const memoryTotal = status.memory?.total || 0;
                        const memoryPercent = memoryTotal > 0 ? (memoryUsed / memoryTotal * 100) : 0;
                        
                        // „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÁµ±Ë®à„ÇíÂèñÂæó
                        let networkData = null;
                        try {
                            const netstat = await this.apiRequest(`/nodes/${nodeName}/netstat`);
                            if (netstat && netstat.length > 0) {
                                // ÂÖ®„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ„ÅÆÂêàË®àÂÄ§„ÇíË®àÁÆó
                                let totalRxBytes = 0;
                                let totalTxBytes = 0;
                                for (const iface of netstat) {
                                    totalRxBytes += parseInt(iface.receive_bytes || 0);
                                    totalTxBytes += parseInt(iface.transmit_bytes || 0);
                                }
                                networkData = {
                                    interfaces: netstat.length,
                                    total_rx_bytes: totalRxBytes,
                                    total_tx_bytes: totalTxBytes,
                                    details: netstat.map(iface => ({
                                        name: iface.device,
                                        rx_bytes: parseInt(iface.receive_bytes || 0),
                                        tx_bytes: parseInt(iface.transmit_bytes || 0),
                                        rx_packets: parseInt(iface.receive_packets || 0),
                                        tx_packets: parseInt(iface.transmit_packets || 0)
                                    }))
                                };
                            }
                        } catch (netError) {
                            console.log(`‚ö†Ô∏è  „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØÁµ±Ë®àÂèñÂæóÂ§±Êïó ${nodeName}: ${netError.message}`);
                        }

                        // „Éá„Ç£„Çπ„ÇØÊÉÖÂ†±„ÇíÂèñÂæó
                        let diskData = null;
                        try {
                            const diskList = await this.apiRequest(`/nodes/${nodeName}/disks/list`);
                            if (diskList && diskList.length > 0) {
                                let totalSize = 0;
                                let totalUsed = 0;
                                const diskDetails = [];
                                
                                for (const disk of diskList) {
                                    const size = parseInt(disk.size || 0);
                                    const used = parseInt(disk.used || 0);
                                    totalSize += size;
                                    totalUsed += used;
                                    
                                    if (size > 0) {
                                        diskDetails.push({
                                            device: disk.devpath || disk.device,
                                            model: disk.model || 'Unknown',
                                            size: size,
                                            used: used,
                                            usage_percent: used > 0 ? (used / size) * 100 : 0,
                                            type: disk.type || 'disk'
                                        });
                                    }
                                }
                                
                                diskData = {
                                    total_size: totalSize,
                                    total_used: totalUsed,
                                    usage_percent: totalSize > 0 ? (totalUsed / totalSize) * 100 : 0,
                                    disks_count: diskDetails.length,
                                    details: diskDetails
                                };
                            }
                        } catch (diskError) {
                            console.log(`‚ö†Ô∏è  „Éá„Ç£„Çπ„ÇØÊÉÖÂ†±ÂèñÂæóÂ§±Êïó ${nodeName}: ${diskError.message}`);
                        }

                        const nodeData = {
                            name: nodeName,
                            status: node.status,
                            cpu: (status.cpu || 0) * 100,
                            maxcpu: status.maxcpu || status.cpuinfo?.cpus || 1,
                            memory_used: memoryUsed,
                            memory_total: memoryTotal,
                            memory_percent: memoryPercent,
                            uptime: status.uptime || 0,
                            loadavg: status.loadavg || [0, 0, 0],
                            network: networkData,
                            disk: diskData,
                            host: this.host  // „Å©„ÅÆProxmox„Éõ„Çπ„Éà„Åã„Çâ„ÅÆ„Éá„Éº„Çø„ÅãË≠òÂà•
                        };
                        data.nodes.push(nodeData);
                        
                        // Ë©≥Á¥∞„Å™„É≠„Ç∞Âá∫Âäõ
                        const networkInfo = networkData ? `„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ: ${((networkData.total_rx_bytes + networkData.total_tx_bytes) / 1024 / 1024 / 1024).toFixed(2)}GB (${networkData.interfaces}IF)` : '„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ: N/A';
                        const diskInfo = diskData ? `„Éá„Ç£„Çπ„ÇØ: ${diskData.usage_percent.toFixed(1)}% (${diskData.disks_count}Âè∞)` : '„Éá„Ç£„Çπ„ÇØ: N/A';
                        
                        console.log(`üìà „Éé„Éº„ÉâÁµ±Ë®à ${nodeName}: CPU=${nodeData.cpu.toFixed(1)}%, „É°„É¢„É™=${memoryPercent.toFixed(1)}% (${(memoryUsed/1024/1024/1024).toFixed(1)}GB/${(memoryTotal/1024/1024/1024).toFixed(1)}GB), ${networkInfo}, ${diskInfo}`);
                    }

                    // VM‰∏ÄË¶ß
                    const vms = await this.apiRequest(`/nodes/${nodeName}/qemu`);
                    if (vms) {
                        for (const vm of vms) {
                            data.vms.push({
                                id: vm.vmid,
                                name: vm.name || `VM-${vm.vmid}`,
                                status: vm.status,
                                node: nodeName,
                                host: this.host,
                                type: 'vm',
                                cpu: vm.cpu ? vm.cpu * 100 : 0,
                                memory: vm.mem || 0,
                                maxmem: vm.maxmem || 0
                            });
                        }
                        console.log(`üñ•Ô∏è  ${nodeName}: ${vms.length}ÂÄã„ÅÆVM`);
                    }

                    // „Ç≥„É≥„ÉÜ„Éä‰∏ÄË¶ß
                    const containers = await this.apiRequest(`/nodes/${nodeName}/lxc`);
                    if (containers) {
                        for (const ct of containers) {
                            data.vms.push({
                                id: ct.vmid,
                                name: ct.name || `CT-${ct.vmid}`,
                                status: ct.status,
                                node: nodeName,
                                host: this.host,
                                type: 'container',
                                cpu: ct.cpu ? ct.cpu * 100 : 0,
                                memory: ct.mem || 0,
                                maxmem: ct.maxmem || 0
                            });
                        }
                        console.log(`üì¶ ${nodeName}: ${containers.length}ÂÄã„ÅÆ„Ç≥„É≥„ÉÜ„Éä`);
                    }

                    // „Çπ„Éà„É¨„Éº„Ç∏ÊÉÖÂ†±
                    const storage = await this.apiRequest(`/nodes/${nodeName}/storage`);
                    if (storage) {
                        for (const store of storage) {
                            data.storage.push({
                                node: nodeName,
                                name: store.storage,
                                type: store.type || 'unknown',
                                total: store.total || 0,
                                used: store.used || 0,
                                available: store.avail || 0
                            });
                        }
                    }
                } catch (nodeError) {
                    console.error(`‚ùå „Éé„Éº„Éâ ${nodeName} „ÅÆ„Éá„Éº„ÇøÂèñÂæó„Ç®„É©„Éº:`, nodeError.message);
                    // ÂÄãÂà•„Éé„Éº„Éâ„ÅÆ„Ç®„É©„Éº„ÅØÂÖ®‰Ωì„Å´ÂΩ±Èüø„Åï„Åõ„Å™„ÅÑ
                    continue;
                }
            }

            console.log(`‚úÖ „Éá„Éº„ÇøÂèñÂæóÂÆå‰∫Ü: ${this.host} - „Éé„Éº„Éâ:${data.nodes.length}, VM/CT:${data.vms.length}`);
            return data;

        } catch (error) {
            console.error(`‚ùå „ÇØ„É©„Çπ„Çø„Éº„Éá„Éº„ÇøÂèñÂæó„Ç®„É©„Éº ${this.host}:`, error.message);
            data.cluster_status = 'offline';
            throw error; // „Ç®„É©„Éº„Çí‰∏ä‰Ωç„Å´‰ºùÊí≠„Åó„Å¶„Éï„Çß„Ç§„É´„Ç™„Éº„Éê„Éº„Çí‰øÉ„Åô
        }
    }
}

class DatabaseManager {
    constructor(dbPath = 'monitoring.db') {
        this.dbPath = dbPath;
        this.db = new sqlite3.Database(dbPath);
        this.initDatabase();
    }

    initDatabase() {
        const sql = `
            CREATE TABLE IF NOT EXISTS metrics_history (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                total_cpu REAL,
                total_memory_used INTEGER,
                total_memory_total INTEGER,
                nodes_count INTEGER,
                vms_running INTEGER,
                vms_total INTEGER
            )
        `;
        
        this.db.run(sql, (err) => {
            if (err) {
                console.error('„Éá„Éº„Çø„Éô„Éº„ÇπÂàùÊúüÂåñ„Ç®„É©„Éº:', err);
            } else {
                console.log('‚úÖ „Éá„Éº„Çø„Éô„Éº„ÇπÂàùÊúüÂåñÂÆå‰∫Ü');
            }
        });
    }

    saveMetrics(data) {
        const nodes = data.nodes || [];
        const vms = data.vms || [];
        
        // „Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Éé„Éº„Éâ„ÅÆ„Åø„ÇíÂØæË±°„Å®„Åó„ÅüÁµ±Ë®à
        const activeNodes = nodes.filter(node => node.status === 'online');
        
        const totalCpu = activeNodes.length > 0 ? activeNodes.reduce((sum, node) => sum + node.cpu, 0) / activeNodes.length : 0;
        const totalMemoryUsed = activeNodes.reduce((sum, node) => sum + node.memory_used, 0);
        const totalMemoryTotal = activeNodes.reduce((sum, node) => sum + node.memory_total, 0);
        const vmsRunning = vms.filter(vm => vm.status === 'running').length;

        console.log('üíæ Áµ±Ë®à‰øùÂ≠ò:', {
            activeNodes: activeNodes.length,
            totalNodes: nodes.length,
            avgCpu: totalCpu.toFixed(1),
            memoryUsedGB: (totalMemoryUsed / 1024 / 1024 / 1024).toFixed(1),
            memoryTotalGB: (totalMemoryTotal / 1024 / 1024 / 1024).toFixed(1),
            vmsRunning: vmsRunning,
            vmsTotal: vms.length
        });

        const sql = `
            INSERT INTO metrics_history 
            (total_cpu, total_memory_used, total_memory_total, nodes_count, vms_running, vms_total)
            VALUES (?, ?, ?, ?, ?, ?)
        `;

        this.db.run(sql, [totalCpu, totalMemoryUsed, totalMemoryTotal, activeNodes.length, vmsRunning, vms.length], (err) => {
            if (err) {
                console.error('„É°„Éà„É™„ÇØ„Çπ‰øùÂ≠ò„Ç®„É©„Éº:', err);
            }
        });
    }

    getHistory(hours = 24) {
        return new Promise((resolve, reject) => {
            const sql = `
                SELECT 
                    timestamp,
                    total_cpu,
                    (total_memory_used * 100.0 / total_memory_total) as memory_percent,
                    vms_running
                FROM metrics_history 
                WHERE timestamp > datetime('now', '-${hours} hours')
                ORDER BY timestamp
            `;

            this.db.all(sql, [], (err, rows) => {
                if (err) {
                    reject(err);
                } else {
                    const history = rows.map(row => ({
                        time: row.timestamp,
                        cpu: row.total_cpu,
                        memory: row.memory_percent,
                        vms: row.vms_running
                    }));
                    resolve(history);
                }
            });
        });
    }
}

class ProxmoxMonitor {
    constructor() {
        this.clients = [];
        this.database = new DatabaseManager();
        this.latestData = {};
        this.isRunning = false;
        this.updateInterval = null;
        
        this.loadConfig();
    }

    loadConfig() {
        try {
            const configPath = path.resolve(__dirname, CONFIG_PATH);
            console.log(`üìÑ Ë®≠ÂÆö„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø: ${configPath}`);
            
            const configFile = fs.readFileSync(configPath, 'utf8');
            const config = yaml.parse(configFile);
            console.log('üìÑ Ë®≠ÂÆö„Éï„Ç°„Ç§„É´ÂÜÖÂÆπ:', JSON.stringify(config, null, 2));

            // Proxmox„Éõ„Çπ„ÉàË®≠ÂÆö„ÅÆË™≠„ÅøËæº„Åø
            // „Åô„Åπ„Å¶„ÅÆË®≠ÂÆö„ÅØconfig.yaml„Åã„Çâ„ÄÅ„Éë„Çπ„ÉØ„Éº„Éâ„ÅÆ„ÅøÁí∞Â¢ÉÂ§âÊï∞„Åã„ÇâÂèñÂæó
            let proxmoxHosts;
            if (Array.isArray(config.proxmox)) {
                // config.yaml „ÅÆ proxmox „ÅåÁõ¥Êé•ÈÖçÂàó„ÅÆÂ†¥Âêà
                proxmoxHosts = config.proxmox;
            } else if (config.proxmox && config.proxmox.hosts) {
                // config.yaml „ÅÆ proxmox.hosts „ÅåÈÖçÂàó„ÅÆÂ†¥Âêà
                proxmoxHosts = config.proxmox.hosts;
            } else {
                throw new Error('Proxmox„Éõ„Çπ„ÉàË®≠ÂÆö„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
            }

            if (!proxmoxHosts || !Array.isArray(proxmoxHosts)) {
                throw new Error('Proxmox„Éõ„Çπ„ÉàË®≠ÂÆö„ÅåÈÖçÂàó„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì');
            }

            console.log(`üîß Áô∫Ë¶ã„Åï„Çå„ÅüProxmox„Éõ„Çπ„Éà: ${proxmoxHosts.length}Âè∞ÔºàÂÜóÈï∑ÂåñÊßãÊàêÔºâ`);

            for (let i = 0; i < proxmoxHosts.length; i++) {
                const hostConfig = proxmoxHosts[i];
                
                // „Éë„Çπ„ÉØ„Éº„Éâ„ÅÆ„ÅøÁí∞Â¢ÉÂ§âÊï∞„Åã„ÇâÂèñÂæóÔºà„Çª„Ç≠„É•„É™„ÉÜ„Ç£„ÅÆ„Åü„ÇÅÔºâ
                const passwordEnvVar = `PROXMOX_PASSWORD_${i + 1}`;
                const password = process.env[passwordEnvVar] || hostConfig.password;
                
                if (!password) {
                    console.warn(`‚ö†Ô∏è „Éë„Çπ„ÉØ„Éº„Éâ„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì: ${hostConfig.host} (${passwordEnvVar})`);
                    continue;
                }
                
                const priority = i === 0 ? '„Éó„É©„Ç§„Éû„É™' : `„Çª„Ç´„É≥„ÉÄ„É™(${i})`;
                console.log(`üîß Proxmox„ÇØ„É©„Ç§„Ç¢„É≥„ÉàË®≠ÂÆö [${priority}]: ${hostConfig.host}:${hostConfig.port || 8006} (user: ${hostConfig.username})`);
                
                const client = new ProxmoxClient(
                    hostConfig.host,
                    hostConfig.username,
                    password,
                    hostConfig.verify_ssl || false
                );
                this.clients.push(client);
            }

            console.log(`‚úÖ ÂÜóÈï∑ÂåñË®≠ÂÆöÂÆå‰∫Ü: ${this.clients.length}Âè∞„ÅÆProxmox„Çµ„Éº„Éê„ÉºÔºàÂÑ™ÂÖàÈ†Ü‰ΩçÈ†ÜÔºâ`);
        } catch (error) {
            console.error('‚ùå Ë®≠ÂÆöË™≠„ÅøËæº„Åø„Ç®„É©„Éº:', error.message);
            process.exit(1);
        }
    }

    async startMonitoring() {
        if (this.isRunning) return;
        
        this.isRunning = true;
        console.log('üöÄ ProxmoxÁõ£Ë¶ñÈñãÂßã...');

        const updateData = async () => {
            try {
                console.log('üìä „Éá„Éº„ÇøÊõ¥Êñ∞ÈñãÂßã...');
                
                const allData = {
                    nodes: [],
                    vms: [],
                    storage: [],
                    cluster_status: 'online',
                    active_api_host: null
                };

                // ÂÜóÈï∑ÊßãÊàêÔºöÊúÄÂàù„Å´ÂøúÁ≠î„Åô„Çã„Éõ„Çπ„Éà„Åã„Çâ„ÅÆ„Åø„Éá„Éº„Çø„ÇíÂèñÂæó
                let dataFetched = false;
                let lastError = null;
                
                for (let i = 0; i < this.clients.length; i++) {
                    const client = this.clients[i];
                    console.log(`ÔøΩ APIÊé•Á∂öË©¶Ë°å (${i + 1}/${this.clients.length}): ${client.host}`);
                    
                    try {
                        const data = await client.getClusterData();
                        if (data && data.nodes.length > 0) {
                            // ÊàêÂäü„Åó„Åü„Éõ„Çπ„Éà„Åã„Çâ„Éá„Éº„Çø„ÇíÂèñÂæó
                            allData.nodes = data.nodes.map(node => ({
                                ...node,
                                source_host: client.host
                            }));
                            allData.vms = data.vms.map(vm => ({
                                ...vm,
                                source_host: client.host
                            }));
                            allData.storage = data.storage.map(storage => ({
                                ...storage,
                                source_host: client.host
                            }));
                            allData.active_api_host = client.host;
                            
                            console.log(`‚úÖ „Éá„Éº„ÇøÂèñÂæóÊàêÂäü: ${client.host} - „Éé„Éº„Éâ:${data.nodes.length}, VM/CT:${data.vms.length}`);
                            dataFetched = true;
                            break; // ÊàêÂäü„Åó„Åü„Çâ‰ªñ„ÅÆ„Éõ„Çπ„Éà„ÅØË©¶Ë°å„Åó„Å™„ÅÑ
                        }
                    } catch (error) {
                        lastError = error;
                        console.log(`‚ùå APIÊé•Á∂öÂ§±Êïó (${i + 1}/${this.clients.length}): ${client.host} - ${error.message}`);
                        continue; // Ê¨°„ÅÆ„Éõ„Çπ„Éà„ÇíË©¶Ë°å
                    }
                }
                
                if (!dataFetched) {
                    console.error('‚ùå ÂÖ®„Å¶„ÅÆProxmox„Éõ„Çπ„Éà„Å∏„ÅÆÊé•Á∂ö„Å´Â§±Êïó');
                    allData.cluster_status = 'offline';
                    if (lastError) {
                        console.error('ÊúÄÂæå„ÅÆ„Ç®„É©„Éº:', lastError.message);
                    }
                } else {
                    console.log(`ÔøΩ „Ç¢„ÇØ„ÉÜ„Ç£„ÉñAPI„Éõ„Çπ„Éà: ${allData.active_api_host}`);
                }

                this.latestData = allData;
                this.database.saveMetrics(allData);

                // WebSocket„Åß„ÇØ„É©„Ç§„Ç¢„É≥„Éà„Å´ÈÄÅ‰ø°
                io.emit('data_update', allData);

                console.log(`‚úÖ „Éá„Éº„ÇøÊõ¥Êñ∞ÂÆå‰∫Ü - „Éé„Éº„Éâ:${allData.nodes.length}, VM/CT:${allData.vms.length}`);

            } catch (error) {
                console.error('‚ùå „Éá„Éº„ÇøÊõ¥Êñ∞„Ç®„É©„Éº:', error.message);
            }
        };

        // ÂàùÂõûÂÆüË°å
        await updateData();
        
        // ÂÆöÊúüÂÆüË°å (10ÁßíÈñìÈöî)
        this.updateInterval = setInterval(updateData, 10000);
    }

    stopMonitoring() {
        this.isRunning = false;
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
            this.updateInterval = null;
        }
        console.log('üõë ProxmoxÁõ£Ë¶ñÂÅúÊ≠¢');
    }

    getLatestData() {
        return this.latestData;
    }

    async getHistory() {
        return await this.database.getHistory();
    }
}

// ProxmoxÁõ£Ë¶ñ„Ç§„É≥„Çπ„Çø„É≥„Çπ
const monitor = new ProxmoxMonitor();

// „É´„Éº„ÉàË®≠ÂÆö
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

app.get('/health', (req, res) => {
    res.status(200).json({
        status: 'healthy',
        uptime: process.uptime(),
        timestamp: new Date().toISOString(),
        version: require('./package.json').version
    });
});

app.get('/api/status', (req, res) => {
    res.json({
        success: true,
        data: monitor.getLatestData(),
        timestamp: new Date().toISOString()
    });
});

app.get('/api/history', async (req, res) => {
    try {
        const history = await monitor.getHistory();
        res.json({
            success: true,
            data: history,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: error.message,
            data: []
        });
    }
});

// WebSocketÊé•Á∂ö
io.on('connection', (socket) => {
    console.log('üë• „ÇØ„É©„Ç§„Ç¢„É≥„ÉàÊé•Á∂ö:', socket.id);
    
    // ÊúÄÊñ∞„Éá„Éº„Çø„ÇíÂç≥Â∫ß„Å´ÈÄÅ‰ø°
    socket.emit('data_update', monitor.getLatestData());
    
    socket.on('disconnect', () => {
        console.log('üëã „ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂàáÊñ≠:', socket.id);
    });
});

// „Çµ„Éº„Éê„ÉºËµ∑Âãï
server.listen(PORT, () => {
    console.log('üöÄ ProxmoxÁõ£Ë¶ñ„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâËµ∑ÂãïÂÆå‰∫Ü');
    console.log(`üìä „ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ: http://localhost:${PORT}`);
    console.log(`üîó „Çπ„ÉÜ„Éº„Çø„ÇπAPI: http://localhost:${PORT}/api/status`);
    console.log(`üìà Â±•Ê≠¥API: http://localhost:${PORT}/api/history`);
    
    // Áõ£Ë¶ñÈñãÂßã
    monitor.startMonitoring();
});

// ÁµÇ‰∫ÜÂá¶ÁêÜ
process.on('SIGINT', () => {
    console.log('\nüõë „Çµ„Éº„Éê„ÉºÁµÇ‰∫Ü‰∏≠...');
    monitor.stopMonitoring();
    server.close(() => {
        console.log('‚úÖ „Çµ„Éº„Éê„ÉºÁµÇ‰∫ÜÂÆå‰∫Ü');
        process.exit(0);
    });
});

process.on('SIGTERM', () => {
    monitor.stopMonitoring();
    server.close(() => {
        process.exit(0);
    });
});
